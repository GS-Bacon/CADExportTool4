using System.Diagnostics;
using System.Net.Http.Headers;
using System.Reflection;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.Json;
using CADExportTool.Core.Interfaces;

namespace CADExportTool.Services;

/// <summary>
/// GitHub Issuesへのエラー自動報告サービス
/// </summary>
public class ErrorReportingService : IErrorReportingService
{
    private const string GitHubApiUrl = "https://api.github.com/repos/GS-Bacon/CADExportTool4/issues";
    private const string UserAgent = "CADExportTool4";
    private const string SettingsFileName = "error_reporting_settings.json";

    private readonly HttpClient _httpClient;
    private readonly string _settingsPath;
    private bool _isEnabled;

    public ErrorReportingService()
    {
        _httpClient = new HttpClient();
        _httpClient.DefaultRequestHeaders.Add("User-Agent", UserAgent);
        _httpClient.DefaultRequestHeaders.Add("Accept", "application/vnd.github.v3+json");

        var appDataPath = Path.Combine(
            Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
            "CADExportTool4");

        if (!Directory.Exists(appDataPath))
        {
            Directory.CreateDirectory(appDataPath);
        }

        _settingsPath = Path.Combine(appDataPath, SettingsFileName);
        LoadSettings();
    }

    public bool IsEnabled
    {
        get => _isEnabled;
        set
        {
            _isEnabled = value;
            SaveSettings();
        }
    }

    public Task<ErrorReportResult> ReportErrorAsync(
        Exception exception,
        string? additionalContext = null,
        CancellationToken cancellationToken = default)
    {
        if (!IsEnabled)
        {
            return Task.FromResult(new ErrorReportResult(false, null, "Error reporting is disabled"));
        }

        try
        {
            var title = $"[Auto Report] {exception.GetType().Name}: {TruncateString(exception.Message, 100)}";
            var body = BuildIssueBody(exception, additionalContext);

            // GitHub Personal Access Tokenが必要
            // ユーザーが設定していない場合は、ブラウザでIssue作成ページを開く
            var issueUrl = BuildNewIssueUrl(title, body);

            // ブラウザでIssue作成ページを開く
            Process.Start(new ProcessStartInfo
            {
                FileName = issueUrl,
                UseShellExecute = true
            });

            return Task.FromResult(new ErrorReportResult(true, issueUrl, null));
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Error reporting failed: {ex.Message}");
            return Task.FromResult(new ErrorReportResult(false, null, ex.Message));
        }
    }

    public Task<bool> AskForPermissionAsync(Exception exception)
    {
        // WPF側でダイアログを表示するため、ここではtrueを返す
        // 実際の許可確認はUI層で行う
        return Task.FromResult(true);
    }

    private string BuildIssueBody(Exception exception, string? additionalContext)
    {
        var sb = new StringBuilder();

        sb.AppendLine("## Error Details");
        sb.AppendLine();
        sb.AppendLine($"**Exception Type:** `{exception.GetType().FullName}`");
        sb.AppendLine();
        sb.AppendLine($"**Message:** {exception.Message}");
        sb.AppendLine();

        sb.AppendLine("## Stack Trace");
        sb.AppendLine();
        sb.AppendLine("```");
        sb.AppendLine(exception.StackTrace ?? "No stack trace available");
        sb.AppendLine("```");
        sb.AppendLine();

        if (exception.InnerException != null)
        {
            sb.AppendLine("## Inner Exception");
            sb.AppendLine();
            sb.AppendLine($"**Type:** `{exception.InnerException.GetType().FullName}`");
            sb.AppendLine();
            sb.AppendLine($"**Message:** {exception.InnerException.Message}");
            sb.AppendLine();
        }

        sb.AppendLine("## Environment");
        sb.AppendLine();
        sb.AppendLine($"- **App Version:** {GetAppVersion()}");
        sb.AppendLine($"- **OS:** {RuntimeInformation.OSDescription}");
        sb.AppendLine($"- **.NET Version:** {RuntimeInformation.FrameworkDescription}");
        sb.AppendLine($"- **Architecture:** {RuntimeInformation.ProcessArchitecture}");
        sb.AppendLine();

        if (!string.IsNullOrEmpty(additionalContext))
        {
            sb.AppendLine("## Additional Context");
            sb.AppendLine();
            sb.AppendLine(additionalContext);
            sb.AppendLine();
        }

        sb.AppendLine("---");
        sb.AppendLine("*This issue was automatically generated by CADExportTool4's error reporting system.*");

        return sb.ToString();
    }

    private string BuildNewIssueUrl(string title, string body)
    {
        var baseUrl = "https://github.com/GS-Bacon/CADExportTool4/issues/new";
        var encodedTitle = Uri.EscapeDataString(title);
        var encodedBody = Uri.EscapeDataString(body);
        var labels = Uri.EscapeDataString("bug,auto-report");

        return $"{baseUrl}?title={encodedTitle}&body={encodedBody}&labels={labels}";
    }

    private static string GetAppVersion()
    {
        var assembly = Assembly.GetEntryAssembly() ?? Assembly.GetExecutingAssembly();
        var version = assembly.GetName().Version;
        return version != null ? $"v{version.Major}.{version.Minor}.{version.Build}" : "Unknown";
    }

    private static string TruncateString(string str, int maxLength)
    {
        if (string.IsNullOrEmpty(str) || str.Length <= maxLength)
        {
            return str;
        }

        return str[..(maxLength - 3)] + "...";
    }

    private void LoadSettings()
    {
        try
        {
            if (File.Exists(_settingsPath))
            {
                var json = File.ReadAllText(_settingsPath);
                var settings = JsonSerializer.Deserialize<ErrorReportingSettings>(json);
                _isEnabled = settings?.IsEnabled ?? false;
            }
        }
        catch
        {
            _isEnabled = false;
        }
    }

    private void SaveSettings()
    {
        try
        {
            var settings = new ErrorReportingSettings { IsEnabled = _isEnabled };
            var json = JsonSerializer.Serialize(settings);
            File.WriteAllText(_settingsPath, json);
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Failed to save settings: {ex.Message}");
        }
    }

    private class ErrorReportingSettings
    {
        public bool IsEnabled { get; set; }
    }
}
